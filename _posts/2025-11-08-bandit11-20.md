---
layout: post
title: Bandit 11 - 20
category: OverTheWire
---

### BANDIT 11

Alright, so logging into **Bandit 11**

We see we're dealing with more data.  

Here are the specifications:  
> "All lowercase (a-z) and uppercase (A-Z) letters have been rotated by 13 positions"

So this one's definitely more difficult than before.  

Since all the letters have been rotated by 13 positions, it sounds like we're dealing with more of a cipher.  

More specifically, the **ROT13 cipher**, which replaces each letter with the 13th letter after it.

It seems like in order to decode it, we will need to use the **tr command** (translate command).  

Okay, so with this particular cipher, they translated the standard alphabet set (`A-Z` and `a-z`)  
to a different set with a 13-letter offset, which looks like  
this set (`N-Z` and `n-z`).  

So `A-Z` and `a-z` == `N-Z` and `n-z` in this case, so using the translate command, we will  
tell it to map each letter back to its unrotated letter.

So first, we'll `cat` the data and pipe the output into the translate command and map the two sets together, which looks like:

```bash
cat data.txt | tr 'a-zA-Z' 'n-za-mN-ZA-M'
```

which will give us the flag.

---

### BANDIT 12

Okay, apparently the password is stored in the file `data.txt`, and it's a **hexdump file** that has undergone numerous compressions.  

Anyway, so what seems to need to be done is we need to create a directory to work in (which it's saying to do in temp, probably to leave no trace).  

So using the `mktemp -d` command (making a directory in the temp folder).  

After making that directory, we need to move there to work there, so changing directories with `cd` lets us move there.  

Now we can copy the data file to this directory (we have more permissions in this directory).  

Using the copy command (`cp`), we can:

```bash
cp ~/data.txt .
```

(which copies it to the current directory we are in).  

Then let's rename the `data.txt` file to a new file named **hexdump** using the move command (`mv`):

```bash
mv data.txt hexdump
```

Then we need to dump the contents into a new file and work from there.  

Using the `xxd` command with the `-r` flag, we can reverse the hexdump into a new file.  

When we get the data, it looks scrambled (probably because it's compressed).  

---

Okay, now here's the fun part.  
So in the hexdump file it tells us the signature of the type of compression method that was used in the header, so using `head` we see `1f8b 08`,  
which means it's **gzip compressed**.  

For gzip compressed files, the header is `\x1F\x8B\x08`.  

In order to decompress, we need to make the data file a gzip file (that's because it's compressed into a gzip file, so we change the name to `data.gz` using the `mv` command) via:

```bash
mv data data.gz
```

Then decompress it using:

```bash
gzip -d data.gz
```

But when we read it, we notice that the file is not fully decompressed, so doing the same thing we did before, we will `xxd` the file, and the first few bytes that pop up is a **bz2 file**.  

When looking up `425a 68`, we see it's a **bzip2 file (version 2)**.  

So we change it to a bzip2 file and then decompress it again:

```bash
mv data data.bz2
bzip2 -d data.bz2
```

Then we `cat` it and notice it's still compressed, so let's read the hex version of it again:

```bash
xxd data
```

First few bytes we see is `1f8b 08`,  
which is another **gzip file**.  

oooo we're getting close lol.  

Let's do it again.  

What we get is an endless abyss of code lol, no worries.  

Instead, do:

```bash
xxd data | head
```

(`head` only prints the first 10 lines of code).  

And when we use the command `file` on the file we see it's a **tar archive**.  

So we change the file to a tar file and extract it using:

```bash
tar -xf data.tar
```

When we list, we get out a file called `data5.bin`.  

So we extract the bin file again and we get `data6.bin`.  

Let's read the header — another **bzip2 file**.  

So when we convert it and decompress it, we get another **tar archive** (I know because I used the `file` command).  

Now we get a `data8.bin` file which is a **gzipped compressed file** — now let's decompress it.

---

**AND AFTER A CENTURY WE FINALLY GOT THE FLAG!**

### BANDIT 13


"Okay so hopping into bandit 13 we see automatically a 

file named sshkey.private

apparently it can only be read by bandit14 

so realistically all we need to down is get the key and use it to login to bandit 14 we dont need to read it just use it

my original thought is to attempt to downoad it using scp lets try that

HAHAHA Perfect it worked you do need the previous password from the last level to get it but using the command 

```bash
scp -P 2220 bandit13@bandit.labs.overthewire.org:sshkey.private .   
```

We tell SCP (file transfer over SSH) on port 2220 to log in with bandit13 and download the SSH key.

Now we can log into Bandit 14.

First, we have to give it the proper permissions using chmod 

via `chmod 600 sshkey.private`

then we can use the key to login

```bash
ssh -i sshkey.private -p 2220 bandit14@bandit.labs.overthewire.org
```

## BANDIT 14

Okay logging in we see 

that theres no immediate file in the directory so lets look at what the objective is

"The password for the next level can be retrieved by submitting the password of the current level to port 30000 on localhost."

The password for this level is in "/etc/bandit_pass/bandit14"

So let's read that.

`Cat /etc/bandit_pass/bandit14`

Anyway, using Netcat, we can interact with the 30000 port on the localhost. 

When we do `nc 127.0.0.1 (localhost) 30000 (port)`

and submit the password, we receive an output of the words Correct! Then another password for the next levels.

Bandit 15 

so by submitting bandit 14 password to port 30001 using ssl we will get the flag

so using openssl lets do that

s_client (is the client were connecting to)

then the -connect flag means connect to localhost on port 30001

```bash
openssl s_client -connect localhost:30001
```

and boom we submit the flag and there it is

## BANDIT 16

so we need to do the same thing as the previous level except this time we got to find the port ourselves

in the range of 31000 to 32000

Out of those, we have to find which ones speak SSL/TLS and which don't. 

So to start, we will use the nmap command to find the open ports on the localhost

and we see only a few open ports 

```
31046/tcp open  unknown
31518/tcp open  unknown
31691/tcp open  unknown
31790/tcp open  unknown - 
31960/tcp open  unknown
```

now we will attempt to connect to them via openssl 

after connecting to each port we find he right port and get a RSA private key :)

Tip: Be sure to use the -quiet command; it'll tell you the password's wrong if you dont.

ONTO THE NEXT

## BANDIT 17

so really we have to compare the two password files

passwords.new and passwords.old 

i used sort to sort them then piped it into the uniq command to find the uniqe strings in the passwords
`sort file1 file2 | uniq -u`
i got two outputs and the second one worked 

## BANDIT 18

after attempting to login to bandit 18

we get logged out apparently the password is in the readme directory but someone changed the .bashrc file to log you out when you login with ssh

but what we learned earlier is we can use SCP to get the file. :)))

using scp we got the readme file and got the password

```bash
scp -P 2220 bandit18@bandit.labs.overthewire.org:~/readme ~
```

## BANDIT 19

so when logging in we see a bandit20-do file that runs commands as the user bandit20

so we know the passwords are located in /etc/bandit_pass/bandit20

so when running the bandit20-do (command) we can read the password for bandit20

## BANDIT 20

Okay so what we need to do is set up a server listening on a port with the current password to that level and we need to execute the suid to connect to it check the password and we will get a password spit back at us and thats how the level is solved

using

```bash
echo -n 'current password' | nc -l -p 1234 &
```

we set up a server on port 1234 that listens for the password we put in there so when we run 

`./suconnect 1234` 

suconnect connects to port 1234 and checks the password with its password and gives us the flag :) great onto the next one"
```
